<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>To: 小羊同学</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Microsoft YaHei', 'Heiti SC', sans-serif;
            touch-action: none;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        #canvas-container {
            opacity: 0;
            transition: opacity 2s ease-in-out;
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 1.1rem; /* 手机上稍微调小一点 */
            letter-spacing: 2px;
            pointer-events: none;
            transition: opacity 0.8s ease-out;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
            animation: pulseText 2s infinite alternate;
            z-index: 100;
            text-align: center;
            width: 90%; /* 防止手机上文字换行太丑 */
            white-space: nowrap;
        }

        @keyframes pulseText {
            0% { opacity: 0.5; text-shadow: 0 0 10px #00ffff; }
            100% { opacity: 1; text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
        }

        #message {
            position: absolute;
            bottom: 15%;
            width: 100%;
            text-align: center;
            color: #e6ffff;
            font-size: 1.2rem; /* 手机字体适配 */
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 20;
            opacity: 0; 
            transition: opacity 1s ease-in-out; 
            text-shadow: 0 0 10px #00ffff, 0 0 20px #0055ff;
            padding: 0 20px;
            box-sizing: border-box;
            line-height: 1.6; 
        }

        .float-anim {
            animation: floatMessage 3s ease-in-out infinite alternate;
        }

        @keyframes floatMessage {
            0% { transform: translateY(0); }
            100% { transform: translateY(-10px); }
        }

        @media (min-width: 768px) {
            /* 电脑端字体稍微大一点 */
            #message { font-size: 1.5rem; letter-spacing: 3px; }
            #loading { font-size: 1.5rem; }
        }
    </style>
</head>

<body>
    <audio id="bgMusic" src="music.mp3" loop preload="auto"></audio>
    <audio id="voice" src="voice.mp3" preload="auto"></audio>

    <div id="loading">✨ 点击屏幕任意位置开启专属浪漫 ✨</div>

    <div id="canvas-container"></div>

    <div id="message"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        let scene, camera, renderer, composer;
        let heartSystem, orbitalsSystem, floorSystem;
        const clock = new THREE.Clock();
        const uniforms = { uTime: { value: 0 } };
        let isAnimating = false;

        const HEART_COUNT = 22000;
        const ORBIT_COUNT = 3500;
        const FLOOR_COUNT = 10000;

        const colorCyan = new THREE.Color(0x00ffff);
        const colorBlue = new THREE.Color(0x0055ff);
        const colorWhite = new THREE.Color(0xffffff);

        const fragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;
            void main() {
                vec2 xy = gl_PointCoord.xy - vec2(0.5);
                float ll = length(xy);
                if (ll > 0.5) discard;
                float intensity = pow(1.0 - (ll * 2.0), 1.5);
                gl_FragColor = vec4(vColor, vAlpha * intensity);
            }
        `;

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // --- 修复1：手机端适配 ---
            // 检测屏幕宽度，如果是手机（小于768px），把相机拉远到 65，否则保持 40
            const isMobile = window.innerWidth < 768;
            const zPosition = isMobile ? 65 : 40; 
            const yPosition = isMobile ? 0 : 5; // 手机上稍微放低一点视角，让爱心居中
            
            camera.position.set(0, yPosition, zPosition);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.1
            );
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createHeart();
            createOrbitals();
            createFloor();

            window.addEventListener('resize', onWindowResize);
            setupInteraction();
        }

        function setupInteraction() {
            const loadingText = document.getElementById('loading');
            const canvasContainer = document.getElementById('canvas-container');
            const bgMusic = document.getElementById('bgMusic');
            const voice = document.getElementById('voice');

            const startExperience = () => {
                if (isAnimating) return;

                // 尝试全屏
                const elem = document.documentElement;
                if (elem.requestFullscreen) { elem.requestFullscreen().catch(() => {}); }
                else if (elem.webkitRequestFullscreen) { elem.webkitRequestFullscreen(); }

                bgMusic.volume = 0.3;
                voice.volume = 1.0;

                // --- 修复2：音频“假动作”预加载 ---
                // 1. 播放背景音乐
                const bgPromise = bgMusic.play();
                
                // 2. 关键：立刻播放录音，然后瞬间暂停并归零
                // 这一步是为了骗过浏览器的“自动播放策略”，让它认为录音已经获得权限
                voice.play().then(() => {
                    voice.pause();
                    voice.currentTime = 0;
                }).catch(e => console.log("语音预加载失败", e));

                if (bgPromise !== undefined) {
                    bgPromise.then(() => {
                        loadingText.style.opacity = '0';
                        setTimeout(() => loadingText.remove(), 1000);
                        canvasContainer.style.opacity = '1';

                        isAnimating = true;
                        clock.start();
                        animate();

                        // 3. 真正播放录音（这次浏览器就不会拦截了）
                        setTimeout(() => {
                            voice.play().catch(e => console.log("语音正式播放失败", e));
                            playTextSequence();
                        }, 1500);

                        document.removeEventListener('click', startExperience);
                        document.removeEventListener('touchstart', startExperience);
                    }).catch(err => {
                        console.log("背景音乐播放被拦截", err);
                    });
                }
            };

            document.addEventListener('click', startExperience);
            document.addEventListener('touchstart', startExperience, { passive: true });
        }

        function playTextSequence() {
            const messages = [
                { text: "亲爱的小羊同学", time: 2000 },
                { text: "新的一年马上就要来到", time: 2500 },
                { text: "我希望你在新的一年里", time: 2500 },
                { text: "更加明媚，更加热烈，也更加有力量", time: 4000 },
                { text: "可以让你不惧一切艰险，勇往直前！", time: 4000 },
                { text: "我也希望你每天都可以更开心一点", time: 3500 },
                { text: "有趣的事我们一起分享，难过的事我们也可以一起承担", time: 5500 }, 
                { text: "在你需要我的时候，我会一直都在", time: 3500 },
                { text: "陪你很久很久", time: 3000 }
            ];
            
            const finalMessage = "小羊同学，每天都要开心哦";
            const msgElement = document.getElementById('message');
            let index = 0;

            function showNextMessage() {
                if (index < messages.length) {
                    const item = messages[index];
                    msgElement.innerText = item.text;
                    msgElement.style.opacity = '1';

                    setTimeout(() => {
                        msgElement.style.opacity = '0';
                        setTimeout(() => {
                            index++;
                            showNextMessage();
                        }, 1000); 
                    }, item.time); 
                } else {
                    msgElement.innerText = finalMessage;
                    msgElement.style.opacity = '1';
                    msgElement.classList.add('float-anim');
                }
            }

            showNextMessage();
        }

        function createHeart() {
            const starts = new Float32Array(HEART_COUNT * 3);
            const targets = new Float32Array(HEART_COUNT * 3);
            const delays = new Float32Array(HEART_COUNT);
            const sizes = new Float32Array(HEART_COUNT);
            const colors = new Float32Array(HEART_COUNT * 3);
            const edges = new Float32Array(HEART_COUNT);

            let validCount = 0;
            while (validCount < HEART_COUNT) {
                let x = (Math.random() - 0.5) * 3.0;
                let y = (Math.random() - 0.5) * 3.0;
                let z = (Math.random() - 0.5) * 3.0;
                let a = x * x + 2.25 * z * z + y * y - 1.0;
                let val = a * a * a - (x * x + 0.1125 * z * z) * y * y * y;

                if (val <= 0.0) {
                    let isSurface = val > -0.15;
                    if (isSurface || Math.random() < 0.1) {
                        let edgeFactor = (val + 0.15) / 0.15;
                        if (val <= -0.15) edgeFactor = 0.0;
                        edges[validCount] = edgeFactor;
                        targets[validCount * 3] = x * 14.0; targets[validCount * 3 + 1] = y * 14.0 + 5.0; targets[validCount * 3 + 2] = z * 14.0;
                        let angle = Math.random() * Math.PI * 2; let r = Math.random() * 20;
                        starts[validCount * 3] = Math.cos(angle) * r; starts[validCount * 3 + 1] = -20; starts[validCount * 3 + 2] = Math.sin(angle) * r;
                        delays[validCount] = Math.random() * 2.0 + (targets[validCount*3+1]+10)/30;
                        sizes[validCount] = Math.random() * 1.2 + 0.4;
                        let rand = Math.random(); let color = new THREE.Color();
                        if (edgeFactor > 0.5 && rand < 0.2) color.copy(colorWhite);
                        else if (rand < 0.6) color.copy(colorCyan);
                        else color.copy(colorBlue).lerp(colorCyan, Math.random());
                        colors[validCount * 3] = color.r; colors[validCount * 3 + 1] = color.g; colors[validCount * 3 + 2] = color.b;
                        validCount++;
                    }
                }
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(starts, 3));
            geometry.setAttribute('aTarget', new THREE.BufferAttribute(targets, 3));
            geometry.setAttribute('aDelay', new THREE.BufferAttribute(delays, 1));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aEdge', new THREE.BufferAttribute(edges, 1));
            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: `
                    uniform float uTime; attribute vec3 aTarget; attribute float aSize; attribute float aDelay; attribute vec3 aColor; attribute float aEdge; varying vec3 vColor; varying float vAlpha;
                    void main() {
                        vColor = aColor; float t = clamp((uTime - aDelay) * 0.4, 0.0, 1.0); float easeT = 1.0 - pow(1.0 - t, 3.0); 
                        vec3 currentPos = mix(position, aTarget, easeT); float angle = easeT * 10.0; float offsetRadius = sin(easeT * 3.14) * 2.0;
                        currentPos.x += cos(angle) * offsetRadius; currentPos.z += sin(angle) * offsetRadius; currentPos.y += sin(uTime * 0.3 + aDelay) * 0.3;
                        vec4 mvPos = modelViewMatrix * vec4(currentPos, 1.0); gl_Position = projectionMatrix * mvPos; gl_PointSize = aSize * (100.0 / -mvPos.z); 
                        float twinkle = 0.5 + 0.5 * sin(uTime * 4.0 + aDelay * 50.0); vAlpha = smoothstep(0.0, 0.1, easeT) * twinkle * mix(0.2, 0.9, aEdge);
                    }
                `,
                fragmentShader: fragmentShader, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            heartSystem = new THREE.Points(geometry, material); scene.add(heartSystem);
        }

        function createOrbitals() {
            const positions = new Float32Array(ORBIT_COUNT * 3); const axes = new Float32Array(ORBIT_COUNT * 3);
            const offsets = new Float32Array(ORBIT_COUNT); const speeds = new Float32Array(ORBIT_COUNT);
            const sizes = new Float32Array(ORBIT_COUNT); const colors = new Float32Array(ORBIT_COUNT * 3);
            for (let i = 0; i < ORBIT_COUNT; i++) {
                let axis = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                let perp = new THREE.Vector3(1, 0, 0); if (Math.abs(axis.x) > 0.9) perp.set(0, 1, 0);
                let pos = new THREE.Vector3().crossVectors(axis, perp).normalize().multiplyScalar(16.0 + Math.random() * 8.0);
                positions[i*3] = pos.x; positions[i*3+1] = pos.y; positions[i*3+2] = pos.z; axes[i*3] = axis.x; axes[i*3+1] = axis.y; axes[i*3+2] = axis.z;
                offsets[i] = Math.random() * Math.PI * 2; speeds[i] = (Math.random() * 0.5 + 0.1) * (Math.random() < 0.5 ? 1 : -1); sizes[i] = Math.random() * 2.0 + 0.5;
                let color = Math.random() > 0.4 ? colorCyan : colorWhite; colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.setAttribute('aAxis', new THREE.BufferAttribute(axes, 3));
            geometry.setAttribute('aOffset', new THREE.BufferAttribute(offsets, 1)); geometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1)); geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: `
                    uniform float uTime; attribute vec3 aAxis; attribute float aOffset; attribute float aSpeed; attribute float aSize;
